Input: clauses; node at a decision level

A: Propagate decision at each level based on clauses
For each new node propagated, send UI:
node generated by propagation
New edges
Once all new nodes have been propagated
	IF conflict not reached, send UI
List of nodes the user can choose at next decision level
Updated clause list
	ELSE send UI
All UIPs
Step 1: Displayed in graph by color, manual user transition to “correct” UIP
“Correct” UIP
Step 2: Uncolor “wrong” UIPs, manual user transition to display cut
Graph cut
Step 3: Draw into UI graph (with colors, or maybe a different library), manual user transition to conflict clause
Conflict clause
Step 4: display conflict clause, Manual user transition to A with updated library
Updated clause list (containing conflict clause)
Loop to A
If you reach an empty clause database - > display the satisfying solution
If you attempt to go above decision level 0 -> no solution



BACK TO FRONT
Propogations:
-nodes generaged
	-string label
	-id (literal.index)
-new edges associated with each node
	-{1:[2,3], 2:[4], 3:[], 4:[]}

Conflict:
-all UIPs
	-list of indices
-closest UIP
	-index
-conflict side of cut
	-list of indices
-other side of cut
	-list indices
-conflict clause
	-str
-new graph
	-{node_index:label, node_index:label}
	-edges {1:[]}

Finished (exit after):
-satisfying solution
	-str

Decision (wait for user input):
-list of nodes user can choose
	-list of indices
	-level